#!/usr/bin/env python3
# ----------------------------------------------------------------------
''' SuperSimple (and useless) unicodeLanguage. Numbers are roman numerals.
push 1 to stack, push 2 to stack, add them, print top of stack:
I⇑⍽II⇑⍽⊕⍽ψ⍽↵  
push 1 to stack, push 11 to stack, swap 1. and 2. item in stack, minus, print:
I⇑⍽XI⇑⍽↔⍽⊖⍽ψ⍽↵
'''
# ----------------------------------------------------------------------
from ply import yacc
import ply.lex # previous phase example snippet code

# tokens are defined in lex-module, but needed here also in syntax rules
tokens = ply.lex.tokens

# any funcion starting with 'p_' is PLY yacc rule
# first definition is the target we want to reduce
# in other words: after processing all input tokens, if this start-symbol
# is the only one left, we do not have any syntax errors

#program ::= codeitem { codeitem }
def p_program(p):
    '''program : codeitem
               | program codeitem'''
    print( 'program' )

#codeitem ::= var_definition | func_definition | statement_seq
def p_codeitem(p):
    '''codeitem : var_definition
                | func_definition
                | statement_seq'''
    print( 'codeitem' )

#var_definition ::= VAR varIDENT IS expr SEMICOLON
def p_var_definition(p):
    '''var_definition : VAR varIDENT IS expr SEMICOLON'''
    print( 'var_definition' )

#func_definition ::= FUNCTION funcIDENT LPAREN [ formals ] RPAREN fbody
def p_func_definition(p):
    '''func_definition : FUNCTION funcIDENT LPAREN formals RPAREN fbody
                       | FUNCTION funcIDENT LPAREN empty RPAREN fbody'''
    print( 'func_definition' )

#formals ::= varIDENT { COMMA varIDENT }
def p_formals(p):
    '''formals : varIDENT
               | varIDENT COMMA varIDENT
               | formals COMMA varIDENT'''
    print( 'formals' )

#fbody ::= RARROW statement_seq END SEMICOLON
def p_fbody(p):
    '''fbody : RARROW statement_seq END SEMICOLON'''
    print( 'fbody' )

#statement_seq ::= statement SEMICOLON { statement SEMICOLON }
def p_statement_seq(p):
    '''statement_seq : statement SEMICOLON
                     | statement_seq statement SEMICOLON'''
    print( 'statement_seq' )


#statement ::= assignment | return_statement | **if_statement**
#            | **while_statement** | **function_call**
def p_statement(p):
    '''statement : assignment
                 | return_statement
                 | if_statement
                 | while_statement
                 | function_call'''
    print( 'statement' )

#return_statement ::= RETURN expr
def p_return_statement(p):
    '''return_statement : RETURN expr'''
    print( 'return_statement' )

#assignment ::= varIDENT [ DOT varIDENT ] LARROW expr
def p_assignment(p):
    '''assignment : varIDENT DOT varIDENT LARROW expr
                  | varIDENT empty LARROW expr'''
    print( 'assignment' )

#expr ::= simple_expr [ ( EQ | NOTEQ | LT | LTEQ | GT | GTEQ ) simple_expr ]
def p_expr(p):
    '''expr : simple_expr
            | simple_expr EQ simple_expr
            | simple_expr NOTEQ simple_expr
            | simple_expr LT simple_expr
            | simple_expr LTEQ simple_expr
            | simple_expr GT simple_expr
            | simple_expr GTEQ simple_expr'''
    print( 'expr' )

#simple_expr ::= term { ( PLUS | MINUS ) term }
def p_simple_expr(p):
    '''simple_expr : term
                   | term PLUS term
                   | term MINUS term
                   | simple_expr PLUS term
                   | simple_expr MINUS term'''
    print( 'simple_expr' )

def p_empty(p):
    'empty :'
    pass


def p_unary_op(p):
    '''unary_op : PUSH'''
    print( 'unary_op(', p[1], ')' )

def p_single_op(p):
    '''single_op : POP
                 | SWAP
                 | ADD
                 | SUB
                 | PRINT'''
    print( 'single_op(', p[1], ')' )

# error token is generated by PLY if the automation enters error state
# (cannot continue reducing or shifting)
def p_error(p):
    print( 'syntax error @', p )
    raise SystemExit

parser = yacc.yacc()

if __name__ == '__main__':
    import argparse, codecs
    arg_parser = argparse.ArgumentParser()
    group = arg_parser.add_mutually_exclusive_group()
    group.add_argument('--who', action='store_true', help='who wrote this' )
    group.add_argument('-f', '--file', help='filename to process')
    ns = arg_parser.parse_args()
    if ns.who == True:
        # identify who wrote this
        print( '85471 Jyke Savia' )
        print( '88888 Ahto Simakuutio' )
    elif ns.file is None:
        # user didn't provide input filename
        arg_parser.print_help()
    else:
        data = codecs.open( ns.file, encoding='utf-8' ).read()
        result = parser.parse(data, lexer=calc_lex.lexer, debug=False)
        if result is None:
            print( 'syntax OK' )

